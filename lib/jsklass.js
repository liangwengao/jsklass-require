"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const isString=e=>"string"===getType(e),isArray=e=>"array"===getType(e),isArrayLike=e=>{let t=!!e&&"length"in e&&e.length,n=getType(e);if("function"===n||isWindow(e))return!1;return"array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e},inArray=(e,t)=>{if(!isArray(e)||!isString(t))return!1;return e.indexOf(t)>-1},mergeArray=(e,t)=>{each(t,(t,n)=>{e.push(n)});return e},convertArgsToArray=e=>Array.prototype.slice.apply(e);var Arrays=Object.freeze({isArray:isArray,isArrayLike:isArrayLike,inArray:inArray,mergeArray:mergeArray,convertArgsToArray:convertArgsToArray});const isObject=e=>"object"===getType(e),mergeObject=(e,t)=>{each(t,(t,n)=>{e[t]=n});return e},shallowCopyObject=(e,t)=>{each(t,function(n,i){t.propertyIsEnumerable(n)&&(e[n]=i)});return e},exit=e=>{throw new Error(e)},error=(e,t)=>{isEmpty(e)||isEmpty(t)?console.error(e):console.error(e,t)},warn=(e,t)=>{isEmpty(e)||isEmpty(t)?console.warn(e):console.warn(e,t)},info=(e,t)=>{isEmpty(e)||isEmpty(t)?console.info(e):console.info(e,t)},log=(e,t)=>{isEmpty(e)||isEmpty(t)?console.log(e):console.log(e,t)};var Console=Object.freeze({exit:exit,error:error,warn:warn,info:info,log:log});const isFunction$$1=e=>"function"===getType(e),getFunctionBind$$1=()=>{Function.prototype.bind||(Function.prototype.bind=function(){let e=this,t=[].shift.call(arguments),n=[].slice.call(arguments);return function(){return e.apply(t,[].concat.call(n,[].slice.call(arguments)))}});return Function.prototype.bind},proxyApplyFunc$$1=(e,t,n)=>{let i=getFunctionBind$$1();n=n||null;t=[n].concat(t);return i.apply(e,t)},evil$$1=e=>{try{return new Function("return "+e)()}catch(e){exit(e)}};var Functions=Object.freeze({isFunction:isFunction$$1,getFunctionBind:getFunctionBind$$1,proxyApplyFunc:proxyApplyFunc$$1,evil:evil$$1});const isJson=e=>{try{if(isString(e)){let t=JSON.parse(e);return!(!isObject(t)||!t)}if(isObject(e)){let t=JSON.stringify(e);return!(!isString(t)||!t)}}catch(e){return!1}},inJson=(e,t)=>{let n=!1;if(!isJson(e)||!isString(t))return n;each(e,(e,i)=>{if(e===t)return n=!0,!1});return n};let class2type={"[object Boolean]":"boolean","[object Number]":"number","[object String]":"string","[object Function]":"function","[object Array]":"array","[object Date]":"date","[object RegExp]":"regexp","[object Object]":"object","[object Error]":"error","[object Symbol]":"symbol"},sToString=class2type.toString,sHasOwn=class2type.hasOwnProperty,sFnToString=sHasOwn.toString,sObjectFunctionString=sFnToString.call(Object);const getType=e=>{if(null===e)return e+"";return"object"==typeof e||"function"==typeof e?class2type[sToString.call(e)]||"object":typeof e},isEmpty=e=>{if(void 0===e||null===e||""===e||void 0===e)return!0;if(isArray(e)||isObject(e)){let t=0;for(let n in e)t++;if(t<=0)return!0}return!1},each=(e,t)=>{let n,i=0;if(isArrayLike(e))for(n=e.length;i<n&&!1!==t.call(e[i],i,e[i]);i++);else for(i in e)if(!1===t.call(e[i],i,e[i]))break;return e},reverseEach=(e,t)=>{let n;if(isArrayLike(e))for(let i=(n=e.length)-1;i>=0&&!1!==t.call(e[i],i,e[i]);i--);else{let n=[];each(e,function(e,t){n.push(e)}),n.sort(function(e,t){return t-e});let i=function(t){let n={};return each(e,function(e,i){if(e.toString()===t.toString())return n=i,!1}),n};each(n,function(e,n){if(!1===t.call(i(n),n,i(n)))return!1})}return e},seal=e=>Object.seal(e),freeze=e=>Object.freeze(e),isWindow=e=>void 0!==e&&e===e.window,isBrowserSide=()=>"undefined"!=typeof window;let oLifetimeUuid=[],sLifetimeKey="";const generateLifetimeUid=function(){let e=[],t="0123456789abcdef",n="";for(let n=0;n<36;n++)e[n]=t.substr(Math.floor(16*Math.random()),1);return e[14]=t.substr(Math.ceil(Math.random()*t.length),1),e[19]=t.substr(3&e[19]|8,1),e[8]=e[13]=e[18]=e[23]="-",n=e.join(""),oLifetimeUuid.indexOf(n)>-1?generateLifetimeUid():(oLifetimeUuid.push(n),n)},getLifetimeKey=function(){if(isEmpty(sLifetimeKey)){let e=[];for(let t=0;t<8;t++)e[t]="0123456789ABCDEF".substr(Math.floor(16*Math.random()),1);sLifetimeKey=e.join("")}return sLifetimeKey},ClassExtends=function(e,t){const n=(e,t)=>{if(!t&&!isFunction$$1(t))return e;e=e.concat(t.constructor||t);if(t._vd_){let i=t._vd_.getSuper(getLifetimeKey());if(!isEmpty(i))return n(e,i)}return e};this.handle=(()=>n(e,t))},ClassInterfaceExtends=function(e,t){const n=(e,t)=>{if(!t&&!isFunction$$1(t))return i(e);if(t._vd_){let i=t._vd_.getInterfaces(getLifetimeKey()),r=t._vd_.getSuper(getLifetimeKey());if(e=mergeArray(e,i),!isEmpty(r))return n(e,r)}return i(e)},i=e=>{let t=[];each(e,(e,n)=>{t.indexOf(n)<0&&t.push(n)});return t};this.handle=(()=>n(e,t))},ConstKeyWord=["class_name","super_class_name","interface_name","static","super","prototype","constructor","lifetime_uid","_vd_","instanceOfInterface","instanceOfClass","$class_name","$super_class_name","$interface_name","$static","$super","$prototype","$constructor","$lifetime_uid","$_vd_","$instanceOfInterface","$instanceOfClass"],ClassKeyWord=["class_name","super_class_name","interface_name","super","prototype","constructor","lifetime_uid","_vd_","instanceOfInterface","instanceOfClass","$class_name","$super_class_name","$interface_name","$super","$prototype","$constructor","$lifetime_uid","$_vd_","$instanceOfInterface","$instanceOfClass"],Implement=function(e,t,n,i,r){let c=["interface_name","lifetime_uid","toString"],o=/%self%/g,s=/%const%/g,a=/%static%/g;const f=e=>e.replace(/[\s+]/g,"").replace(/\{(.*)\}/g,"{}"),u=e=>e.replace(/function\(/g,"(").replace(/\)/g,")=>"),l=e=>{let t=null,n=null;o.test(e)?(t="self",n=e.replace(o,"")):s.test(e)?(t="const",n=e.replace(s,"")):a.test(e)&&(t="static",n=e.replace(a,""));return{type:t,name:n}},p=e=>{let t="",n=!1;switch(e.type){case"function":n=!0,t="function("+e.args.join(",")+"){}";break;case"object":n=!0,t="[object]";break;case"string":n=!0,t="[string]";break;case"number":n=!0,t="[number]";break;default:n=!1,t="[*]"}return{type:e.type,check:n,value:t}},y=(e,t,n,i,r)=>{let c=r.replace(/[\s+]/g,"");if(!e[t])return t+(c?"="+c:"");let o=e[t],s=o.toString(),a=getType(o);if(i)switch(n){case"function":if("function"!==a)return t+(c?"="+c:"");if(f(r)!==f(s)||u(f(r))!==u(f(s)))return t+(c?"="+c:"");break;case"object":if("object"!==a)return t+(c?"="+c:"");break;case"string":if("string"!==a)return t+(c?"="+c:"");break;case"number":if("number"!==a)return t+(c?"="+c:"")}return null},m=function(e){return isBrowserSide()?e:u(e)};this.handle=(()=>{if(isEmpty(i))return!1;let o=new e,s=new function(){},a=null,f=null,u=null;i=isArray(i)?i:[i];each(i,function(e,t){t.apply(s,[])});each(s,(e,i)=>{if(c.indexOf(e)<0){let c=l(e),s=p(i),m=c.name,d=s.value,_=s.type,g=s.check;switch(c.type){case"self":if(ClassKeyWord.indexOf(m)<0&&((a=y(o,m,_,g,d))&&(a=y(r,m,_,g,d)),a))return!1;break;case"const":if(ConstKeyWord.indexOf(m)<0&&(u=y(t,m,_,g,d)))return!1;break;case"static":if(f=y(n,m,_,g,d))return!1;break;default:exit("非法定义的接口体")}}});a&&exit(o.class_name+"的类必须实现接口: self."+m(a));u&&exit(o.class_name+"的类必须实现接口: const."+m(u));f&&exit(o.class_name+"的类必须实现接口: static."+m(f));o=s=null;return!0})},PropertyHandler=function(e,t,n){let i=this,r={},c={},o={},s={},a={};i.setConst=(e=>{isObject(e)&&(c=e)&&(o=shallowCopyObject({},c));return i}),i.setStatic=(e=>{isObject(e)&&(s=e)&&(a=shallowCopyObject({},s));return i}),i.handle=(()=>{reverseEach(t,function(e,t){let i={};"const"===n?t.apply({},[{},i,{},{},{}]):"static"===n?t.apply({},[{},seal(c),i,{},{}]):t.apply({},[{},seal(c),s,{},i]),isEmpty(i)||(r[t.class_name]=i)});c=shallowCopyObject(c,o);s=shallowCopyObject(s,a);each(r,(t,n)=>{each(n,(t,n)=>{e[t]=n});return!0});r={};c={};o={};s={};a={};return e})},validateClass=(e,t,n,i)=>{const r=/^[A-Z][A-Za-z0-9_]+$/g,c="function(?,?){}";e||exit(`没有给定类名`);isString(e)||exit(`类名必须是string类型: ${e}`);r.test(e)||exit(`类命名定义不规范,必须是以大写字母开头: ${e}`);t||exit(`没有定义类结构体: ${e}`);isFunction$$1(t)||exit(`类结构体必须是function类型: ${e}`);const o=t.toString().replace(/[\s+]/g,"").replace(/\{(.*)+\}$/g,"{}").replace(/\((.*)\)/g,"(?,?)");c!==o&&exit(`类结构体定义不规范，必须是 ${c} 格式: ${e}`);n&&(isFunction$$1(n)||exit(`类继承的结构体必须是function类型:${e}`),(isEmpty(n.class_name)||isEmpty(n.lifetime_uid)||isEmpty(n._vd_)||isEmpty(n._vd_.getLifetimeCode(getLifetimeKey())))&&exit(`类继承的结构体不规范:${e}`),isFunction$$1(n)||exit(`类继承的结构体不规范，必须是 ${c} 格式:${e}`));i&&(i=isArray(i)?i:[i],each(i,function(t,n){isFunction$$1(n)||exit(`接口的结构体必须是function类型: ${e}`),(isEmpty(n.interface_name)||isEmpty(n.lifetime_uid)||isEmpty(n._vd_)||isEmpty(n._vd_.getLifetimeCode(getLifetimeKey())))&&exit(`接口的结构体不规范: ${e}`),isFunction$$1(n)||exit(`接口的结构体不规范，必须是 ${c} 格式: ${e}`)}));return!0},validateRule=(e,t)=>{const n=/^[a-zA-Z0-9_$]+$/i;let i=[],r=[],c=[],o="",s="prototype",a=!1,f=!1,u=!1,l=!1,p=!1;reverseEach(t,function(e,t){let y={},m={},d={},_={};return t.apply(y,[y,_,d,freeze({}),m]),each(m,function(e,t){if("_construct"===e)return o=e,s="prototype",f=!0,!1;if("$_construct"===e)return o=e,s="prototype",a=!0,!1;if(ClassKeyWord.indexOf(e)>-1)return o=e,s="prototype",u=!0,!1;if(hasFinalName(e)){let t=filterFinalName(e);if(i.indexOf(t)>-1)return o=t,s="prototype",p=!0,!1;i.push(t)}else if(i.indexOf(e)>-1)return o=e,s="prototype",p=!0,!1}),!(p||u||a||f)&&(each(y,function(e,t){if("$_construct"===e)return o=e,s="self",a=!0,!1;if(ClassKeyWord.indexOf(e)>-1)return o=e,s="self",u=!0,!1;if(hasFinalName(e)){let t=filterFinalName(e);if(i.indexOf(t)>-1)return o=t,s="self",p=!0,!1;i.push(t)}else if(i.indexOf(e)>-1)return o=e,s="self",p=!0,!1}),!(p||u||a||f)&&(each(_,function(e,t){return n.test(e)?ConstKeyWord.indexOf(e)>-1?(o=e,s="const",u=!0,!1):r.indexOf(e)>-1?(o=e,s="const",p=!0,!1):void 0:(o=e,s="const",l=!0,!1)}),!(p||u||a||f||l)&&void each(d,function(e,t){return ClassKeyWord.indexOf(e)>-1?(o=e,s="static",u=!0,!1):c.indexOf(e)>-1?(o=e,s="static",p=!0,!1):void 0})))});if(f)return exit(`${e} 类中的 [${s}] 成员名称不允许是：${o}`),!1;if(u)return exit(`${e} 类中的 [${s}] 成员名称不可是关键词：${o}`),!1;if(p)return exit(`${e} 类中的 [${s}]: ${o} 是final类型不可覆写`),!1;if(a)return exit(`${e} 类中的 [${s}]: ${o} 构造函数不允许设置为final类型！`),!1;if(l)return exit(`${e} 类中的 [${s}]: ${o} 名称必须[a-zA-Z0-9_$]方式命名`),!1;return!0},hasFinalName=e=>{return 0===e.indexOf("$")},filterFinalName=e=>{e=0===e.indexOf("$")?e.replace("$",""):e;return e},VHConstruct=e=>`function(GV, oSupers, oCallSupersConstruct, oSupersConstructList){ oSupers["_construct"] = function(){ if(oCallSupersConstruct.indexOf('${e}') > -1 ){ GV.oConsole.exit("构造函数只允许在创建对象时调用！");} oCallSupersConstruct.push('${e}'); oSupersConstructList['${e}'].apply(this, arguments); }}`,VHClass=(e,t,n)=>{let i={0:{}},r=[0],c={},o=0,s=n,a={},f=shallowCopyObject({},e.oStatic),u=e.oKlass.checkImplement;reverseEach(e.oConstructorList,function(n,s){let f={},l=i[o],p={},y={},m={},d=function(){let e=this;each(y,function(t,n){e[t]=n})};s.apply(t,[t,seal(e.oConst),e.oStatic,freeze(l),p]),n>0&&s.apply(f,[f,seal({}),freeze({}),freeze(l),{}]),o++,each(f,function(n,i){if(isFunction$$1(i))if("_construct"===n)c[o]=t[n],evil$$1(VHConstruct(o))(e,y,r,c);else{let e=u?n:filterFinalName(n);t.propertyIsEnumerable(n)&&(y[e]=t[n])}}),each(l,function(e,t){l.propertyIsEnumerable(e)&&!y[e]&&(y[e]=t)}),each(a,function(e,t){each(t,function(e,t){m[e]=t})}),each(p,function(t,n){if(!u){let e=filterFinalName(t);p[e]=n,delete p[t],t=e}m[t]=n,e.oPrototype[t]=n}),d.prototype=m,i[o]=new d,a[o]=p});!u&&each(t,function(e,n){hasFinalName(e)&&(Object.defineProperty(t,filterFinalName(e),{value:n,writable:!1,enumerable:!0,configurable:!1}),delete t[e])});e.oStatic=shallowCopyObject(e.oStatic,f);u||(t._construct&&(t._construct.apply(t,s),delete t._construct),each(i,function(e,t){e=parseInt(e),r.indexOf(e)<0&&r.push(e)}));a=null},VHPrototype=e=>`function(LV, GV){\n            if(GV.oFunctions.isFunction(GV.oPrototype['${e}'])){            \n              LV['${e}'] = function (){\n              var sl = this, \n              fn = GV.oFunctions.proxyApplyFunc(GV.oPrototype['${e}'], \n              GV.oArrays.convertArgsToArray(arguments), sl); \n              return (fn && fn());}\n            }else{\n              LV['${e}'] = GV.oPrototype['${e}'];\n            }\n          }`,VHInterface=(e,t)=>{reverseEach(e.oConstructorList,function(e,n){let i=new n;each(i,(e,n)=>{t[e]=n})});each(e.oSelf,(e,n)=>{t["%self%"+e]=n});e.oConst&&each(e.oConst,(e,n)=>{t["%const%"+e]=n});e.oStatic&&each(e.oStatic,(e,n)=>{t["%static%"+e]=n})},convertCode=e=>getLifetimeKey()+"@"+e,instanceOfClass=e=>{let t={};t[e.lifetime_uid]=e.class_name;isEmpty(e.super_class_name)||(t=mergeObject(t,e.super_class_name));return e=>{if(isEmpty(e.lifetime_uid)||isEmpty(e._vd_)||isEmpty(e.class_name))return!1;let n=e._vd_.getLifetimeCode(getLifetimeKey()),i="";each(t,(e,t)=>{let r=convertCode(e);if(r===n)return i=t,!1});return i===e.class_name}},instanceOfInterface=e=>{let t=e.interface_name;return e=>{if(isEmpty(e.lifetime_uid)||isEmpty(e._vd_)||isEmpty(e.interface_name))return!1;let n=e._vd_.getLifetimeCode(getLifetimeKey()),i="";each(t,(e,t)=>{let r=convertCode(e);if(r===n)return i=t,!1});return i===e.interface_name}},instanceOf=e=>{let t=convertCode(e.lifetime_uid),n=e.interface_name;return e=>{if(isEmpty(e.lifetime_uid)||isEmpty(e._vd_)||isEmpty(e.interface_name))return!1;let i="",r=e.interface_name;each(r,(e,n)=>{let r=convertCode(e);if(r===t)return i=n,!1});return n===i}},getInterfaces=e=>t=>{let n=[];t===getLifetimeKey()&&(n=isEmpty(e)?[]:e);return n},getLifetimeCode=e=>t=>{let n=e;t===getLifetimeKey()&&(n=convertCode(e));return n},getSuper=e=>t=>{let n=[];t===getLifetimeKey()&&(n=isEmpty(e)?null:e);return n},toString=(e,t)=>()=>e+"@"+t,Class=function(e,t,n,i){let r={},c={},o={},s={},a={},f={},u={oKlass:o,oConst:f,oStatic:a,oConstructorList:t,oPrototype:s,oConsole:Console,handler:VHClass};const l=t,p=n,y=generateLifetimeUid(),m=(e,t)=>{"INTERFACE"===t?inJson(r,e.lifetime_uid)||(r[e.lifetime_uid]=e.interface_name):inJson(c,e.lifetime_uid)||(c[e.lifetime_uid]=e.class_name);if(e._vd_){let n=e._vd_.getSuper(getLifetimeKey());!isEmpty(n)&&m(n,t)}},d=`function (GV){\n           GV.oKlass = function ${e}() {\n              GV.handler(GV, this, arguments);\n           };\n         }\n       `;if(!validateClass(e,t,n,i))return!1;if(i=isArray(i)?i:isEmpty(i)?[]:[i],i=new ClassInterfaceExtends(i,p).handle(),t.class_name=l.class_name=e,t.lifetime_uid=l.lifetime_uid=y,t.interface_name=l.interface_name=r,t=[t],n="function"===getType(n)?n.prototype:{},t=new ClassExtends(t,p).handle(),isEmpty(i)||each(i,function(e,t){m(t,"INTERFACE")}),each(t,function(e,t){e>0&&m(t,"CLASS")}),!validateRule(e,t))return!1;f=new PropertyHandler(f,t,"const").handle(),a=new PropertyHandler(a,t,"static").setConst(f).handle(),s=new PropertyHandler(s,t,"class").setConst(f).setStatic(a).handle();let _=function(){this.class_name=e,this.super_class_name=c,this.interface_name=r,this.lifetime_uid=y,this.instanceOfClass=instanceOfClass(this),this.instanceOfInterface=instanceOfInterface(this),this.toString=toString(y,e),this._vd_=freeze({getLifetimeCode:getLifetimeCode(y)})},g=function(){let e=this,t=[];each(s,function(n,i){hasFinalName(n)&&(n=filterFinalName(n),t.push(n)),"_construct"!==n&&evil$$1(VHPrototype(n))(e,{oArrays:Arrays,oFunctions:Functions,oPrototype:s})}),each(e,function(n,i){t.indexOf(n)>-1&&Object.defineProperty(e,n,{value:i,writable:!1,enumerable:!0,configurable:!1})}),t=[]};return _.prototype=n,g.prototype=new _,u.oConstructorList=t,evil$$1(d)(u),o=u.oKlass,o.constructor=l,o.prototype=new g,o.static=a,o.class_name=e,o.super_class_name=c,o.interface_name=r,o.lifetime_uid=y,o.instanceOfClass=instanceOfClass(o),o.instanceOfInterface=instanceOfInterface(o),o.toString=toString(y,e),o._vd_=freeze({getInterfaces:getInterfaces(i),getLifetimeCode:getLifetimeCode(y),getSuper:getSuper(p)}),o=mergeObject(o,f),o.checkImplement=!0,new Implement(o,f,a,i,s).handle(),o.checkImplement=!1,delete o.checkImplement,freeze(o)},InterfaceExtends=function(e,t){const n=(e,t)=>{if(!t&&"function"!==getType(t))return e;e=e.concat(t.constructor||t);if(t._vd_){let i=t._vd_.getSuper(getLifetimeKey());if(!isEmpty(i))return n(e,i)}return e};this.handle=(()=>n(e,t))},checkInterfaceType=e=>{let t=null;each(e,(e,n)=>{if("InterfaceType"!==n.name)return t=e,!1});return t},validateInterface=(e,t,n,i,r)=>{const c=/^[A-Z][A-Za-z0-9_]+$/g,o=/^[A-Z_$]+$/i;let s=[],a=!1,f=!1,u="",l=!1,p=!1;e||exit(`没有给定接口名`);isString(e)||exit(`接口名必须是string类型: ${e}`);c.test(e)||exit(`接口命名定义不规范,必须是以大写字母开头: ${e}`);if(t){isObject(t)||exit(`接口self结构体必须是object类型: ${e}`),isJson(t)||exit(`接口self结构体必须是{}格式: ${e}`);const n=checkInterfaceType(t);n&&exit(`接口self结构体的值类型不合法，必须是InterfaceType类型: ${e} -> ${n}`);const i=JSON.stringify(t).replace(/[\s+]/g,"").replace(/\{(.*)\}/g,"{}");if("{}"!==i&&exit(`接口self结构体不规范，必须是 {} 格式: ${e}`),each(t,function(e,t){if("$_construct"===e)return u=e,f=!0,!1;if(ClassKeyWord.indexOf(e)>-1)return u=e,a=!0,!1;if(hasFinalName(e)){let t=filterFinalName(e);if(s.indexOf(t)>-1)return u=t,l=!0,!1;s.push(t)}else if(s.indexOf(e)>-1)return u=e,l=!0,!1}),a)return exit(`${e} 接口中self定义的名称不可使用关键：${u}`),!1;if(f)return exit(`${e} 接口中self的 ${u} 构造函数不允许设置为final类型！`),!1;if(l)return exit(`接口self结构体定义的名称已存在：${u}`),!1}if(i){isObject(i)||exit(`接口static的结构体必须是object类型: ${e}`),isJson(i)||exit(`接口static结构体必须是{}格式: ${e}`);const t=JSON.stringify(i).replace(/[\s+]/g,"").replace(/\{(.*)\}/g,"{}");"{}"!==t&&exit(`接口static的结构体定义不规范，必须是 {} 格式: ${e}`);const n=checkInterfaceType(i);n&&exit(`接口static结构体的值类型不合法，必须是InterfaceType类型: ${e} -> ${n}`)}if(n){isObject(n)||exit(`接口const的结构体必须是object类型: ${e}`),isJson(n)||exit(`接口const结构体必须是{}格式: ${e}`);const t=JSON.stringify(n).replace(/[\s+]/g,"").replace(/\{(.*)\}/g,"{}");"{}"!==t&&exit(`接口const的结构体定义不规范，必须是 {} 格式: ${e}`);const i=checkInterfaceType(n);if(i&&exit(`接口const结构体的值类型不合法，必须是InterfaceType类型: ${e} -> ${i}`),each(n,function(e,t){return o.test(e)?ConstKeyWord.indexOf(e)>-1?(u=e,a=!0,!1):void 0:(u=e,p=!0,!1)}),a)return exit(`${e} 接口中Const定义的名称不可使用关键：${u}`),!1;p&&exit(`${e} 接口中Const定义的名称必须全部以大写命名：${u}`)}r&&(isFunction$$1(r)||exit(`接口继承的结构体必须是function类型: ${e}`),(isEmpty(r.interface_name)||isEmpty(r.lifetime_uid)||isEmpty(r._vd_)||isEmpty(r._vd_.getLifetimeCode(getLifetimeKey())))&&exit(`接口继承的结构体定义不规范: ${e}`),isFunction$$1(r)||exit(`接口继承的结构体定义不规范，必须是 function(?,?){} 格式: ${e}`));s=[];return!0},Interface=function(e,t,n,i,r){let c=[],o=isObject(t)?t:{},s={},a={oInterface:s,oConstructorList:c,handler:VHInterface,oStatic:i,isStaticHandle:!1,oConst:n,oSelf:o};const f=r,u=generateLifetimeUid(),l=`function(GV){\n      GV.oInterface = function ${e}() {\n        GV.handler(GV, this);\n      };\n    }`;if(!validateInterface(e,o,n,i,r))return!1;c=new InterfaceExtends(c,f).handle();let p=function(){this.interface_name=e,this.lifetime_uid=u,this.toString=toString(u,e)};return a.oConstructorList=c,evil$$1(l)(a),s=a.oInterface,s.constructor=s,s.interface_name=e,s.prototype=new p,s.lifetime_uid=u,s.instanceOfClass=instanceOf(s),s.toString=toString(u,e),s._vd_=freeze({getLifetimeCode:getLifetimeCode(u),getSuper:getSuper(f)}),Object.freeze(s)},InterfaceTypeRule=function(e,t){this.name="InterfaceType",this.type=e,this.args=t},InterfaceType={function:function(){let e=[];return each(arguments,(t,n)=>{e.push(n)}),Object.freeze(new InterfaceTypeRule("function",e))},objects:function(){return Object.freeze(new InterfaceTypeRule("object",""))},string:function(){return Object.freeze(new InterfaceTypeRule("string",""))},number:function(){return Object.freeze(new InterfaceTypeRule("number",""))},all:function(){return Object.freeze(new InterfaceTypeRule("all",""))}},DefClass=(e,t,n,i)=>new Class(e,t,n,i),DefInterface=(e,t,n,i,r)=>new Interface(e,t,n,i,r);exports.DefClass=DefClass,exports.DefInterface=DefInterface,exports.InterfaceType=InterfaceType;
